using UnityEngine;

using System.Collections;
using System;
using System.Collections.Generic;
[AddComponentMenu("QuickPath/Grid")]
[ExecuteInEditMode]
/// <summary>
/// Creates a grid for MoveObjects to move around on.
/// </summary>
public class qpGrid : MonoBehaviour
{
    /// <summary>
    /// Grid map of all nodes generated. Used for finding and setting node connections.
    /// </summary>
    public qpNode[,] gridNodes;

    /// <summary>
    /// List containing all nodes generated by this grid.
    /// </summary>
    public List<qpNode> allNodes = new List<qpNode>();


    /// <summary>
    /// Start position from which to ray cast for terrain suitable for nodes.
    /// </summary>
    public Vector2 startCoordinate = new Vector3(-50,-50);

    /// <summary>
    /// End position from which to ray cast for terrain suitable for nodes.
    /// </summary>
    public Vector2 endCoordinate = new Vector3(50,50);

    /// <summary>
    /// List of tags that when raycasted against will not create node.
    /// </summary>
    public List<string> DisallowedTags = new List<string>();
    /// <summary>
    /// List of tags that when raycasted against will not create node.
    /// </summary>
    public List<string> IgnoreTags = new List<string>();

    /// <summary>
    /// Draws a line at each node, and draws a line between each connection between two nodes. Helpful when baking grids.
    /// </summary>
    public bool DrawInEditor = true;

    /// <summary>
    /// The Axises
    /// </summary>
    public enum Axis {Y=4,Z=5};

    /// <summary>
    /// The designated updirection.
    /// </summary>
    public Axis UpDirection = Axis.Y;

    /// <summary>
    /// Indicates where the raycasting for generating nodes should start on the updirection axis.
    /// </summary>
    public float UpRaycastStart = 12;

    /// <summary>
    /// Indicates where the raycasting for generating nodes should end on the updirection axis.
    /// </summary>
    public float UpRayCastEnd = -12;

    /// <summary>
    /// Indicates the distance between each node.
    /// </summary>
    public float spread = 1;

    private List<Vector3> _lineRayStarts = new List<Vector3>();
    private List<Vector3> _lineRayEnds = new List<Vector3>();
    private qpManager _manager;
    private bool _generateNodes = true;

    /// <summary>
    /// Awake is called when the script instance is being loaded.
    /// </summary>
	public void Awake () {
        Debug.Log("all nodes:" + allNodes.Count);
        qpManager.Instance.RegisterNodes(allNodes);
        Debug.Log("qpmanager instance nodes:" + qpManager.Instance.nodes.Count);
        //Generate new nodes with raycast collision detection
        if (_generateNodes)
        {
            if (startCoordinate == Vector2.zero && endCoordinate == Vector2.zero && GetComponent<Renderer>() !=null)
            {
                float width = GetComponent<Renderer>().bounds.size.x / 50;
                float height = GetComponent<Renderer>().bounds.size.y / 50;
                startCoordinate = new Vector2(this.transform.position.x - (width * .5f), this.transform.position.y - (height * .5f));
                endCoordinate = new Vector2(startCoordinate.x + width, startCoordinate.y +height);
            }
            Debug.Log("generate nodes from:" + startCoordinate + " to " + endCoordinate);
            _generateGrid();
            //Debug
            
            int connections = 0;
            foreach (qpNode node in allNodes)
            {
                connections += node.Contacts.Count;
               // Debug.Log(node.productionNumber + " contacts:" + node.Contacts.Count);
            }
            Debug.Log("found " + connections + " node connections");
            Debug.Log("found " + allNodes.Count + " nodes.");

        }
	}

    /// <summary>
    /// Deletes nodes and rebuilds the entire grid.
    /// </summary>
    public void Bake()
    {
        _manager = qpManager.Instance;
        _manager.DelistNodes(allNodes);
        allNodes = new List<qpNode>();
        _generateGrid();
        DontDestroyOnLoad(_manager);
        //Debug.Log("nodes:" + allNodes.Count+" disallowed tags:"+DisallowedTags.Count+"DisallowedTag:"+DisallowedTags[2]);
    }

    /// <summary>
    /// Update this instance.
    /// </summary>
    public void Update()
    {
        if (DrawInEditor)
        {
             for (int i = _lineRayStarts.Count; i > 0; i--)
             {
                 Debug.DrawLine(_lineRayStarts[i - 1], _lineRayEnds[i - 1],Color.blue,0,true);
             }
            foreach (qpNode node in allNodes)
            {
                foreach (qpNode node2 in node.Contacts)
                {
                    Debug.DrawLine(node.GetCoordinate(), node2.GetCoordinate(),new Color(0,0,1,.7f),0,true);
                }
            }
        }
    }

    private void _generateGrid()
    {
        _lineRayEnds = new List<Vector3>();
        _lineRayStarts = new List<Vector3>();
        Vector2 size = new Vector2(Mathf.Abs(startCoordinate.x - endCoordinate.x), Mathf.Abs(startCoordinate.y-endCoordinate.y));

        gridNodes = new qpNode[(int)(size.x/spread)+2, (int)(size.y/spread)+2];
        for (int i = 0; i < (size.x/spread)*(size.y/spread); i++)
        {
            int row =(int)Mathf.Floor((i*spread)/size.x);
            float x = ((i*spread)-(row*size.x))+startCoordinate.x + 0.5f;
            float y = (row * spread)+startCoordinate.y + 0.5f;
                Vector3 rayCastPositionEnd = Vector3.zero;
                Vector3 rayCastPositionStart = Vector3.zero;
                Vector3 rayDirection = Vector3.zero;
                if (UpDirection == Axis.Z)
                {
                    rayCastPositionStart = new Vector3(x, y , UpRaycastStart);
                    rayCastPositionEnd = new Vector3(x, y, UpRayCastEnd);
                    rayDirection = new Vector3(0,0,-1f);
                }
                else if (UpDirection == Axis.Y)
                {
                    rayCastPositionStart = new Vector3(x,UpRaycastStart , y );
                    rayCastPositionEnd = new Vector3(x , UpRayCastEnd, y );
                    rayDirection = new Vector3(0,-1f);
                }
                qpGridNode gridNode = null;
                 RaycastHit[] hits;
                 bool placeNode = true;
                 Vector3 point = Vector3.zero;
                hits = Physics.RaycastAll(rayCastPositionStart,rayDirection, 100.0F);
                int o = 0;
                int countIgnoreHits = 0;
                if (hits.Length == 0) placeNode = false;
                while (o < hits.Length)
                {
                    RaycastHit hit = hits[o];
					//Debug.Log(hit.transform.tag);
                    if (DisallowedTags.Contains(hit.transform.tag)) {
						//Debug.Log("Disallowed!");
						placeNode = false;
					}
                    else if (IgnoreTags.Contains(hit.collider.gameObject.tag)) countIgnoreHits++;
                    else point = hit.point;
                    o++;
                }
                if (o == countIgnoreHits) placeNode = false;
                if (placeNode)
                {
                    //Collision detected on floor

                    Vector3 vec = point;
                    //vec.z += 0.25f;
                    gridNode = new qpGridNode(vec);
                    allNodes.Add(gridNode);

                    if (UpDirection == Axis.Z) rayCastPositionStart.z = point.z + 1;
                    else if (UpDirection == Axis.Y) rayCastPositionStart.y = point.y + 1;

                    if (point != Vector3.zero)
                    {
                        _lineRayEnds.Add(point);
                        _lineRayStarts.Add(rayCastPositionStart);
                    }
                }

                int yindex = (int)Mathf.Floor(i / (size.x/spread));
                int xindex = (int)(i - (Mathf.Ceil(yindex * (size.x/spread))));
                //Debug.Log("i:" + i + " spread:" + spread + " dif.x:" + size.x + " dif.y:" + size.y + " row:" + row + " x:" + x + " y:" + y+" xindex:"+xindex+" yindex:"+yindex);
                
                gridNodes[xindex, yindex] = gridNode;
                //Set connection for gridnode
                if (gridNode != null)
                {
                    
                    if ((xindex - 1) > 0)
                    {
                        if (gridNodes[xindex - 1, yindex] != null) gridNode.SetMutualConnection(gridNodes[xindex - 1, yindex]);
                        if((yindex-1)>0)
                        {
                            if (gridNodes[xindex - 1, yindex - 1] != null) gridNode.SetMutualConnection(gridNodes[xindex - 1, yindex - 1], true);
                        }
                    }
                    if ((yindex - 1) > 0)
                    {
                        if (gridNodes[xindex, yindex - 1] != null) gridNode.SetMutualConnection(gridNodes[xindex, yindex - 1]);
                        if (gridNodes[xindex+1, yindex - 1] != null) gridNode.SetMutualConnection(gridNodes[xindex + 1, yindex - 1], true);
                    }
                }
            
        }
        qpManager.Instance.RegisterNodes(allNodes);
    }

    //void OnDisable()
    //{
    //    Debug.Log("instance:" + qpManager.Instance);
    //    Debug.Log("nodes:" + allNodes);
    //    qpManager.Instance.DelistNodes(allNodes);
    //}
    //void OnDestroy()
    //{
    //    qpManager.Instance.DelistNodes(allNodes);
    //}
}